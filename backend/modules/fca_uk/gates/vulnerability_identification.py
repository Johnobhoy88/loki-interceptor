import re


class VulnerabilityIdentificationGate:
    def __init__(self):
        self.name = "vulnerability_identification"
        self.severity = "high"
        self.legal_source = "FCA FG21/1 (Guidance for Firms on the Fair Treatment of Vulnerable Customers)"

    def _is_relevant(self, text):
        """Check if document involves customer interactions or sensitive situations"""
        text_lower = text.lower()
        # ENHANCED: Expanded keywords to catch first-person vulnerability indicators
        keywords = [
            'customer', 'client', 'consumer', 'vulnerable', 'support',
            'bereavement', 'illness', 'disability', 'mental health',
            'financial difficulty', 'debt', 'redundancy',
            # First-person indicators:
            'i\'m', 'i am', 'i have', 'i\'ve', 'my', 'me',
            # Age-related:
            'years old', 'year old', 'age', 'aged', 'elderly', 'older',
            # Health-related direct mentions:
            'widowed', 'widow', 'health', 'care home', 'hospital',
            'difficult', 'struggling', 'worried', 'concerned'
        ]
        return any(kw in text_lower for kw in keywords)

    def check(self, text, document_type):
        if not self._is_relevant(text):
            return {
                'status': 'N/A',
                'message': 'Not applicable - document does not contain vulnerability indicators or customer support context',
                'legal_source': self.legal_source
            }

        text_lower = text.lower()
        spans = []

        # Detect vulnerability drivers (FCA's 4 categories)
        vulnerability_drivers = {
            'health': [
                r'\b(?:illness|ill\s+health|medical|disability|disabled|mental\s+health|depression|anxiety|dementia|alzheimer|cancer|terminal)\b',
                r'health\s+(?:condition|issue|problem)',
                r'(?:physical|mental)\s+(?:health|condition|impairment)'
            ],
            'life_events': [
                r'\b(?:bereavement|bereaved|death|funeral|widow|widower)\b',
                r'\b(?:divorce|separation|relationship\s+breakdown)\b',
                r'\b(?:redundancy|redundant|job\s+loss|unemployment|unemployed)\b',
                r'lost\s+(?:my|their|your)\s+(?:job|partner|spouse)',
                r'recent(?:ly)?\s+(?:lost|died)'
            ],
            'resilience': [
                r'\b(?:debt|indebted|arrears|struggling|difficulty|hardship)\b',
                r'financial\s+(?:difficulty|hardship|problem|struggle)',
                r'(?:can\'t|cannot|unable\s+to)\s+(?:pay|afford)',
                r'low\s+income',
                r'(?:miss|missed|late)\s+payment'
            ],
            'capability': [
                r'\b(?:literacy|illiterate|english|language\s+barrier|learning\s+difficulty)\b',
                r'(?:don\'t|do\s+not|doesn\'t)\s+understand',
                r'(?:difficult|hard)\s+to\s+understand',
                r'(?:old|older|elderly|aging|aged)',
                r'vision\s+(?:impaired|impairment|problem)',
                r'hearing\s+(?:impaired|impairment|loss|problem)'
            ]
        }

        detected_vulnerabilities = {}
        for category, patterns in vulnerability_drivers.items():
            for pattern in patterns:
                matches = list(re.finditer(pattern, text, re.IGNORECASE))
                if matches:
                    if category not in detected_vulnerabilities:
                        detected_vulnerabilities[category] = []
                    for m in matches:
                        detected_vulnerabilities[category].append(m.group())
                        spans.append({
                            'type': f'vulnerability_{category}',
                            'start': m.start(),
                            'end': m.end(),
                            'text': m.group(),
                            'severity': 'medium'
                        })

        # Check for vulnerability acknowledgment/identification
        identification_patterns = [
            r'(?:identify|identif(?:y|ied|ying)|detect|recognis(?:e|ed|ing)|spot)\s+(?:vulnerable|vulnerability)',
            r'vulnerable\s+customer',
            r'customer\s+(?:in\s+)?vulnerable\s+(?:circumstance|situation)',
            r'if\s+you(?:\'re|\s+are)\s+vulnerable',
            r'experiencing\s+vulnerability',
            r'support\s+for\s+vulnerable'
        ]

        has_identification = False
        for pattern in identification_patterns:
            matches = list(re.finditer(pattern, text, re.IGNORECASE))
            if matches:
                has_identification = True
                for m in matches:
                    spans.append({
                        'type': 'vulnerability_identification',
                        'start': m.start(),
                        'end': m.end(),
                        'text': m.group(),
                        'severity': 'none'
                    })

        # Check for vulnerability support/accommodations
        support_patterns = [
            r'(?:additional|extra|special)\s+support',
            r'alternative\s+(?:format|method|channel)',
            r'(?:flexible|extended)\s+(?:time|deadline|payment)',
            r'(?:we\s+can|able\s+to)\s+(?:help|assist|support)',
            r'reasonable\s+adjustment',
            r'accommodate\s+(?:your\s+)?(?:needs|circumstances)'
        ]

        has_support_offer = False
        for pattern in support_patterns:
            matches = list(re.finditer(pattern, text, re.IGNORECASE))
            if matches:
                has_support_offer = True
                for m in matches:
                    spans.append({
                        'type': 'vulnerability_support',
                        'start': m.start(),
                        'end': m.end(),
                        'text': m.group(),
                        'severity': 'none'
                    })

        # Determine status
        vulnerability_count = len(detected_vulnerabilities)

        # If vulnerability indicators detected but not acknowledged
        if vulnerability_count > 0 and not has_identification:
            details = []
            details.append(f'Detected categories: {", ".join(list(detected_vulnerabilities.keys()))}')
            for k, v in detected_vulnerabilities.items():
                if v[:2]:
                    details.append(f'{k} examples: {", ".join(v[:2])}')
            return {
                'status': 'WARNING',
                'severity': 'medium',
                'message': f'Vulnerability indicators detected ({vulnerability_count} categories) but not explicitly acknowledged',
                'legal_source': self.legal_source,
                'suggestion': 'FG21/1 requires firms to identify vulnerable customers. Acknowledge vulnerabilities and offer appropriate support.',
                'spans': spans,
                'details': details
            }

        # If vulnerability detected and identified but no support offered
        if vulnerability_count > 0 and has_identification and not has_support_offer:
            details = []
            details.append(f'Detected categories: {", ".join(list(detected_vulnerabilities.keys()))}')
            return {
                'status': 'WARNING',
                'severity': 'medium',
                'message': 'Vulnerability identified but no support measures mentioned',
                'legal_source': self.legal_source,
                'suggestion': 'Offer reasonable adjustments, additional support, alternative formats, or flexible arrangements.',
                'spans': spans,
                'details': details
            }

        # If vulnerability handled appropriately
        if vulnerability_count > 0 and has_identification and has_support_offer:
            details = []
            details.append(f'Detected categories: {", ".join(list(detected_vulnerabilities.keys()))}')
            return {
                'status': 'PASS',
                'severity': 'none',
                'message': f'Vulnerability appropriately identified and support offered ({vulnerability_count} categories)',
                'legal_source': self.legal_source,
                'spans': spans,
                'details': details
            }

        # If vulnerability identified in general terms (proactive)
        if has_identification:
            return {
                'status': 'PASS',
                'severity': 'none',
                'message': 'Proactive vulnerability identification process referenced',
                'legal_source': self.legal_source,
                'spans': spans
            }

        # No vulnerability indicators
        return {'status': 'N/A'}
